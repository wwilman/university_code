# -*- coding: utf-8 -*-
"""Heart_disease_prediction_Wilman.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OWQE6E500yi44b58Hy5-S7YQgwdlbdLM

# **PREDICTING HEART DISEASE FROM CLINICAL AND LABORATORIAL DATA USING KNN**

# About the data

Source of the data: 
[Kaggle](https://www.kaggle.com/ronitf/heart-disease-uci?select=heart.csv)

## The Atribute information

1. age
2. sex
3. cp :chest pain type (4 values)
4. trestbs :resting blood pressure
5. chol :serum cholestoral in mg/dl 
6. fbs :fasting blood sugar > 120 mg/dl
7. restecg :resting electrocardiographic results (values 0,1,2)
8. thalach :
9. exang :maximum heart rate achieved
exercise induced angina
10. oldpeak :ST depression induced by exercise relative to rest
11. slope :the slope of the peak exercise ST segment
12. ca :number of major vessels (0-3) colored by flourosopy
13. thal: 3 = normal; 6 = fixed defect; 7 = reversable defect
14. target :0 is no heart disease and 1 is heart disease

## Aim of the prediction

Developing a predictive model capable of accurately predicting the presence or absence of heart disease from clinical and laboratory data using a K-Nearest-Neighbors Classifier, based on [Coursera course](https://www.coursera.org/projects/predicting-heart-disease-using-machine-learning).

# Introduction

Importations:
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import GridSearchCV
from sklearn import metrics
# %matplotlib inline

data = pd.read_csv('heart.csv')
data.head()

Shape:

data.shape

"""Variable types:"""

data.dtypes

"""# Exploratory Data Analysis

Outcome variable count:
"""

sns.catplot(x='target', kind='count', palette='ch:.25', data = data)

"""Categorical predictive variables:

sex:
"""

sns.catplot(x='sex',kind='count',hue='target', palette='ch:.25', data=data)

"""cp:"""

sns.catplot(x='cp',kind='count',hue='target', palette='ch:.25', data=data)

"""fbs:"""

sns.catplot(x='fbs',kind='count',hue='target', palette='ch:.25', data=data)

"""restecg:"""

sns.catplot(x='restecg',kind='count',hue='target', palette='ch:.25', data=data)

"""exang:"""

sns.catplot(x='exang',kind='count',hue='target', palette='ch:.25', data=data)

"""slope:"""

sns.catplot(x='slope',kind='count',hue='target', palette='ch:.25', data=data)

"""ca:"""

sns.catplot(x='ca',kind='count',hue='target', palette='ch:.25', data=data)

"""thal:"""

sns.catplot(x='thal',kind='count',hue='target', palette='ch:.25', data=data)

"""Distributinal predictive variables:"""

data[['age','trestbps','chol','thalach','oldpeak']].describe()

sns.displot(x='age',multiple='stack',hue='target', palette='ch:.25',data=data)

sns.displot(x='trestbps',multiple='stack',hue='target', palette='ch:.25',data=data)

sns.displot(x='chol',multiple='stack',hue='target', palette='ch:.25',data=data)

sns.displot(x='thalach',multiple='stack',hue='target', palette='ch:.25',data=data)

sns.displot(x='oldpeak',multiple='stack',hue='target', palette='ch:.25',data=data)

"""# Spliting and Pre-processing:

Defining x_train, x_test, y_train and y_train:
"""

x = data.drop('target', axis=1)
y = data['target']
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42 )

"""Scaling the data by standarize:"""

sc = StandardScaler().fit(x_train)
x_train = sc.transform(x_train)
x_test = sc.transform(x_test)

"""# Train the model:

Parameters for grid search:
"""

knn =KNeighborsClassifier()
parameters = {'n_neighbors':[3,5,7,9,11], 'weights':['uniform','distance']}

"""Fiting training data and grid searching:"""

grid = GridSearchCV(knn, parameters, cv=4, scoring='accuracy')
grid.fit(x_train, y_train)

Displaying best parameters:

print(grid.best_params_)

Picking the best model:

model = grid.best_estimator_

"""# Evaluation of the model:

Model score on the data:
"""

model.score(x_test,y_test)

"""Confusion matrix:"""

predictions = model.predict(x_test)
cm = metrics.confusion_matrix(y_test, predictions)
cm = pd.DataFrame(cm)
sns.heatmap(cm, annot=True)
plt.show()

"""Calculation of sensivity, specificity, PPV and NPV:"""

TP = 28
FP = 2
TN = 27
FN = 4
sensitivity = TP / (TP + FN)*100
specificity = TN / (TN + FP)*100
ppv = TP/ (TP + FP)* 100
npv = TN/ (TN + FN)*100

print('Sensitivity:', sensitivity,'% ','Specificity:', specificity,'% ','positive predictive value:',ppv,'% ','negative predictive value:',npv,'%' )

"""AUC score:"""

probs = model.predict_proba(x_test)[:,1]
auc = metrics.roc_auc_score(y_test, probs)
print(auc)

"""ROC curve:"""

fpr, tpr, _ = metrics.roc_curve(y_test, probs)
plt.figure()
plt.grid()
plt.plot(fpr, tpr)
plt.plot([0,1],[0,1])
plt.show()
